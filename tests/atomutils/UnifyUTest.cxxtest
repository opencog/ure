/**
 * tests/atomspace/UnifyUTest.cxxtest
 *
 * Copyright (C) 2016 OpenCog Foundation
 * All Rights Reserved
 * Author: Nil Geisweiller
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/atomutils/Unify.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

class UnifyUTest :  public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	SchemeEval _eval;
	Handle X, Y, Z, W, V, A, B, AB, XB, AY, XY, AZ, AW, AV,
		AndAA, AndAB, AndAY, AndXB, AndXY,
		AndAABB, AndXYAB, AndAAABBB, AndXXYYAB, AndAAAABBBB, AndXXXYYYAB,
		AndAAAAABBBBB, AndXXXXYYYYAB,
		CT, PT, IT, CPT,
		X_vardecl, X_cyclic_vardecl, Y_vardecl, Z_vardecl, W_vardecl, V_vardecl,
		XY_vardecl;
	
public:
	UnifyUTest() : _eval(&_as) {}

	void setUp();

	// Type (TODO: should be moved elsewhere once the unification type
	// routines are moved elsewhere)
	void test_type_intersection();

	void test_join_1();
	void test_join_2();
	void test_join_3();

	void test_unify_without_var_1();
	void test_unify_without_var_2();

	void test_unify_basic_1();
	void test_unify_basic_2();
	void test_unify_basic_3();
	void test_unify_basic_4();
	void test_unify_basic_5();
	void test_unify_basic_6();
	void test_unify_basic_7();
	void test_unify_basic_8();

	// Variable declaration
	void test_unify_vardecl_1();
	void test_unify_vardecl_2();
	void test_unify_vardecl_3();
	void test_unify_vardecl_4();
	void test_unify_vardecl_5();

	// // Cyclic dependence
	// TODO: is it really needed?
	// void test_unify_cyclic_dependence_1();

	// // Type union
	// TODO: for that we need to support more powerful type
	// void test_unify_type_union_1();

	// Unordered link
	void test_unify_unordered_1();
	void test_unify_unordered_2();
	void test_unify_unordered_3();
	void test_unify_unordered_4();
	void test_unify_unordered_5();
	void test_unify_unordered_6();
	void test_unify_unordered_7();
	void test_unify_unordered_8();

	// Various complex unify queries
	void test_unify_complex_1();
	void test_unify_complex_2();
	void test_unify_complex_3();
};

void UnifyUTest::setUp(void)
{
#define al _as.add_link
#define an _as.add_node

	X = an(VARIABLE_NODE, "$X");
	Y = an(VARIABLE_NODE, "$Y");
	Z = an(VARIABLE_NODE, "$Z");
	W = an(VARIABLE_NODE, "$W");
	V = an(VARIABLE_NODE, "$V");
	A = an(CONCEPT_NODE, "A");
	B = an(CONCEPT_NODE, "B");
	AB = al(INHERITANCE_LINK, A, B);
	XB = al(INHERITANCE_LINK, X, B);
	AY = al(INHERITANCE_LINK, A, Y);
	XY = al(INHERITANCE_LINK, X, Y);
	AZ = al(INHERITANCE_LINK, A, Z);
	AW = al(INHERITANCE_LINK, A, W);
	AV = al(INHERITANCE_LINK, A, V);
	AndAA = al(AND_LINK, A, A);
	AndAB = al(AND_LINK, A, B);
	AndAY = al(AND_LINK, A, Y);
	AndXB = al(AND_LINK, X, B);
	AndXY = al(AND_LINK, X, Y);
	AndAABB = al(AND_LINK, {A, A, B, B});
	AndXYAB = al(AND_LINK, {X, Y, A, B});
	AndAAABBB = al(AND_LINK, {A, A, A, B, B, B});
	AndXXYYAB = al(AND_LINK, {X, X, Y, Y, A, B});
	AndAAAABBBB = al(AND_LINK, {A, A, A, A, B, B, B, B});
	AndXXXYYYAB = al(AND_LINK, {X, X, X, Y, Y, Y, A, B});
	AndAAAAABBBBB = al(AND_LINK, {A, A, A, A, A, B, B, B, B, B});
	AndXXXXYYYYAB = al(AND_LINK, {X, X, X, X, Y, Y, Y, Y, A, B});
	CT = an(TYPE_NODE, "ConceptNode");
	PT = an(TYPE_NODE, "PredicateNode");
	IT = an(TYPE_NODE, "InheritanceLink");
	CPT = al(TYPE_CHOICE, CT, PT);
	X_vardecl = al(TYPED_VARIABLE_LINK, X, CT);
	X_cyclic_vardecl = al(TYPED_VARIABLE_LINK, X, IT);
	Y_vardecl = al(TYPED_VARIABLE_LINK, Y, CT);
	Z_vardecl = al(TYPED_VARIABLE_LINK, Z, CT);
	W_vardecl = al(TYPED_VARIABLE_LINK, W, PT);
	V_vardecl = al(TYPED_VARIABLE_LINK, V, CPT);
	XY_vardecl = al(VARIABLE_LIST,
	                al(TYPED_VARIABLE_LINK, X, CT),
	                al(TYPED_VARIABLE_LINK, Y, CT));

#undef al
#undef an
}

void UnifyUTest::test_type_intersection()
{
	Handle lhs =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");
	Handle rhs =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle result = type_intersection(lhs, rhs),
		expected = rhs;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_join_1()
{
	Unify::Block pb1{X, A};
	Unify::SolutionSet s1 = Unify::SolutionSet(true, {{{pb1, A}}});
	Unify::Block pb2{X, B};
	Unify::SolutionSet s2 = Unify::SolutionSet(true, {{{pb2, B}}}),
		result = Unify().join(s1, s2),
		expected = Unify::SolutionSet(false);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_join_2()
{
	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_implicant =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Unify::Context C(Quotation(), {X});
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify::Block pb1{P, implicant};
	Unify::SolutionSet s1 = Unify::SolutionSet(true, {{{pb1, implicant}}});
	Unify::Block pb2{P, quoted_implicant};
	Unify::SolutionSet s2 = Unify::SolutionSet(true, {{{pb2, quoted_implicant}}});
	Unify::SolutionSet result = Unify().join(s1, s2);
	Unify::Block pb1_expected{P, implicant, quoted_implicant};
	Unify::Block pb2_expected{TyVs, Cimplicant_vardecl};
	Unify::Block pb3_expected{A1, Cimplicant_body};
	Unify::SolutionSet expected =
		Unify::SolutionSet(true, {{{pb1_expected, implicant},
					               {pb2_expected, implicant_vardecl},
						           {pb3_expected, implicant_body}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

// Same as test_join_2 but using A2 as well. See test_complex_1
void UnifyUTest::test_join_3()
{
	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle Q = _eval.eval_h("(VariableNode \"$Q\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_LA1 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle quoted_LA2 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A2\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Unify::Context C(Quotation(), {X});
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify::SolutionSet
		s1 = Unify::SolutionSet(true, {{{{P, implicant}, implicant}}}),
		s2 = Unify::SolutionSet(true,
		           {{{{P, quoted_LA1}, quoted_LA1},
					 {{Q, quoted_LA2}, quoted_LA2}},
		            {{{Q, quoted_LA1}, quoted_LA1},
					 {{P, quoted_LA2}, quoted_LA2}}}),
		result = Unify().join(s1, s2),
		expected = Unify::SolutionSet(true, {{{{P, implicant, quoted_LA2},
						 	                   implicant},
						                      {{TyVs, Cimplicant_vardecl},
						 	                   implicant_vardecl},
						                      {{A2, Cimplicant_body},
								               implicant_body},
						                      {{Q, quoted_LA1},
								               quoted_LA1}},
				                             {{{P, implicant, quoted_LA1},
						 	                   implicant},
						                      {{TyVs, Cimplicant_vardecl},
						 	                   implicant_vardecl},
						                      {{A1, Cimplicant_body},
								               implicant_body},
						                      {{Q, quoted_LA2},
								               quoted_LA2}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_without_var_1()
{
	Unify::SolutionSet result = Unify()(AB, A),
		expected(false);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_without_var_2()
{
	Unify::SolutionSet result = Unify()(AB, AB),
		expected(true);

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_1()
{
	Unify::SolutionSet result = Unify()(X, A),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_2()
{
	Unify::SolutionSet result = Unify()(A, X),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_3()
{
	Unify::SolutionSet result = Unify()(X, AB),
		expected = Unify::SolutionSet(true, {{{{X, AB}, AB}}});
	
	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_4()
{
	Unify::SolutionSet result = Unify()(XB, AY),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}, {{Y, B}, B}}});
	
	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_5()
{
	Unify::SolutionSet result = Unify()(XY, AY),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}, {{Y, Y}, Y}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_basic_6()
{
	// This one is supposed to fail
	Unify::SolutionSet result = Unify()(A, B);

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.satisfiable);
}

void UnifyUTest::test_unify_basic_7()
{
	// This one is supposed to fail
	Unify::SolutionSet result = Unify()(XB, B);

	TS_ASSERT(not result.satisfiable);
}

void UnifyUTest::test_unify_basic_8()
{
	Unify::SolutionSet result = Unify()(XY, AZ),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}, {{Y, Z}, Y}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_1()
{
	Unify::SolutionSet result = Unify()(X, A, X_vardecl),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_2()
{
	Unify::SolutionSet result = Unify()(XY, AY, XY_vardecl, Y_vardecl),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}, {{Y}, Y}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_3()
{
	Unify::SolutionSet result = Unify()(XB, AY, X_vardecl, Y_vardecl),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}, {{Y, B}, B}}});

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_4()
{
	Unify::SolutionSet result = Unify()(XY, AZ, XY_vardecl, Z_vardecl),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}, {{Y, Z}, Y}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_vardecl_5()
{
	// This one is supposed to fail as the types of Y and W have empty
	// intersection.
	Unify::SolutionSet result = Unify()(XY, AW, XY_vardecl, W_vardecl);

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.satisfiable);
}

// void UnifyUTest::test_unify_cyclic_dependence_1()
// {
// 	// This one is supposed to fail as X cannot be an Inheritance link
// 	// and a ConceptNode as specified by its type declaration.
// 	Unify::SolutionSet result = Unify()(XY, X, XY_vardecl, X_cyclic_vardecl);

// 	std::cout << "result = " << oc_to_string(result) << std::endl;

// 	TS_ASSERT(not result.satisfiable);
// }

// void UnifyUTest::test_unify_type_union_1()
// {
// 	Unify::SolutionSet result = Unify()(XY, AV, XY_vardecl, V_vardecl),
// 		expected = Unify::SolutionSet(true, {{{{X, A}, A}, {{Y, V}, Y}}});

// 	std::cout << "result = " << oc_to_string(result) << std::endl;
// 	std::cout << "expected = " << oc_to_string(expected) << std::endl;

// 	TS_ASSERT_EQUALS(result, expected);
// }

void UnifyUTest::test_unify_unordered_1()
{
	Unify::SolutionSet result = Unify()(AndAA, AndAB);

	std::cout << "result = " << oc_to_string(result) << std::endl;

	TS_ASSERT(not result.satisfiable);
}

void UnifyUTest::test_unify_unordered_2()
{
	Unify::SolutionSet result = Unify()(AndAB, AndAY,
	                                    Handle::UNDEFINED, Y_vardecl),
		expected = Unify::SolutionSet(true, {{{{Y, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_3()
{
	Unify::SolutionSet result = Unify()(AndAY, AndXB),
		expected = Unify::SolutionSet(true, {{{{X, A}, A}, {{Y, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_4()
{
	Unify::SolutionSet result = Unify()(AndAB, AndXY,
	                                    Handle::UNDEFINED, XY_vardecl),
		expected = Unify::SolutionSet(true,
		                              {{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;
}

void UnifyUTest::test_unify_unordered_5()
{
	Unify::SolutionSet result = Unify()(AndAABB, AndXYAB),
		expected = Unify::SolutionSet(true,
		                              {{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_6()
{
	Unify::SolutionSet result = Unify()(AndAAABBB, AndXXYYAB),
		expected = Unify::SolutionSet(true,
		                              {{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_7()
{
	Unify::SolutionSet result = Unify()(AndAAAABBBB, AndXXXYYYAB),
		expected = Unify::SolutionSet(true,
		                              {{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_unordered_8()
{
	Unify::SolutionSet result = Unify()(AndAAAAABBBBB, AndXXXXYYYYAB),
		expected = Unify::SolutionSet(true,
		                              {{{{X, A}, A}, {{Y, B}, B}},
			                           {{{Y, A}, A}, {{X, B}, B}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyUTest::test_unify_complex_1()
{
	Handle lhs =
		_eval.eval_h("(ImplicationLink"
		             "  (LambdaLink"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$X\")"
		             "      (TypeNode \"ConceptNode\"))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (ConceptNode \"treatment-1\"))))"
		             "  (AndLink"
		             "    (QuoteLink"
		             "      (LambdaLink"
		             "        (UnquoteLink"
		             "          (VariableNode \"$TyVs\"))"
		             "        (UnquoteLink"
		             "          (VariableNode \"$A1\"))))"
		             "    (QuoteLink"
		             "      (LambdaLink"
		             "        (UnquoteLink"
		             "          (VariableNode \"$TyVs\"))"
		             "        (UnquoteLink"
		             "          (VariableNode \"$A2\"))))))");
	Handle rhs =
		_eval.eval_h("(ImplicationLink"
		             "   (VariableNode \"$P\")"
		             "   (And"
		             "      (VariableNode \"$P\")"
		             "      (VariableNode \"$Q\")))");
	Handle lhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs-5476a9b9\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableNode\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$A1-7235efc6\")"
		             "    (TypeNode \"EvaluationLink\"))"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$A2-1ac8e4a2\")"
		             "    (TypeNode \"EvaluationLink\")))");
	Handle rhs_vardecl =
		_eval.eval_h("(VariableList"
		             "   (TypedVariableLink"
		             "      (VariableNode \"$P\")"
		             "      (TypeChoice"
		             "         (TypeNode \"PredicateNode\")"
		             "         (TypeNode \"LambdaLink\")))"
		             "   (TypedVariableLink"
		             "      (VariableNode \"$Q\")"
		             "      (TypeChoice"
		             "         (TypeNode \"PredicateNode\")"
		             "         (TypeNode \"LambdaLink\")))))");

	Handle P = _eval.eval_h("(VariableNode \"$P\")");
	Handle Q = _eval.eval_h("(VariableNode \"$Q\")");
	Handle TyVs = _eval.eval_h("(VariableNode \"$TyVs\")");
	Handle A1 = _eval.eval_h("(VariableNode \"$A1\")");
	Handle A2 = _eval.eval_h("(VariableNode \"$A2\")");

	Handle implicant =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"treatment-1\"))))");

	Handle quoted_LA1 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A1\"))))");

	Handle quoted_LA2 =
		_eval.eval_h("(QuoteLink"
		             "  (LambdaLink"
		             "    (UnquoteLink"
		             "      (VariableNode \"$TyVs\"))"
		             "    (UnquoteLink"
		             "      (VariableNode \"$A2\"))))");

	Handle implicant_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"treatment-1\")))");

	Unify::Context C(Quotation(), {X});
	Unify::CHandle Cimplicant_vardecl(implicant_vardecl, C),
		Cimplicant_body(implicant_body, C);

	Unify::SolutionSet result = Unify()(lhs, rhs, lhs_vardecl, rhs_vardecl),
		expected = Unify::SolutionSet(true, {{{{P, implicant, quoted_LA2},
						 	                   implicant},
						                      {{TyVs, Cimplicant_vardecl},
						 	                   implicant_vardecl},
						                      {{A2, Cimplicant_body},
								               implicant_body},
						                      {{Q, quoted_LA1},
								               quoted_LA1}},
				                             {{{P, implicant, quoted_LA1},
						 	                   implicant},
						                      {{TyVs, Cimplicant_vardecl},
						 	                   implicant_vardecl},
						                      {{A1, Cimplicant_body},
								               implicant_body},
						                      {{Q, quoted_LA2},
								               quoted_LA2}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle ts_vardecl = _eval.eval_h("(VariableList"
	                                 "  (TypedVariableLink"
	                                 "    (VariableNode \"$TyVs-5476a9b9\")"
	                                 "    (TypeChoice"
	                                 "      (TypeNode \"TypedVariableLink\")"
	                                 "      (TypeNode \"VariableNode\")"
	                                 "      (TypeNode \"VariableList\")))"
	                                 "  (TypedVariableLink"
	                                 "    (VariableNode \"$A1-7235efc6\")"
	                                 "    (TypeNode \"EvaluationLink\"))"
	                                 "  (TypedVariableLink"
	                                 "    (VariableNode \"$A2-1ac8e4a2\")"
	                                 "    (TypeNode \"EvaluationLink\"))"
	                                 "  (VariableNode \"$P\")"
	                                 "  (VariableNode \"$Q\"))");

	Handle consumed_LA1 =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$A1\"))");

	Handle consumed_LA2 =
		_eval.eval_h("(LambdaLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$A2\"))");

	Unify::TypedSubstitutions ts_result =
		Unify().typed_substitutions(result, lhs, lhs, rhs,
		                            lhs_vardecl, rhs_vardecl);
	Unify::TypedSubstitutions ts_expected =
		Unify::TypedSubstitutions{{{{P, implicant},
		                            {TyVs, Cimplicant_vardecl},
		                            {A2, Cimplicant_body},
		                            {Q, consumed_LA1}},
		                           ts_vardecl},
		                          {{{P, implicant},
		                            {TyVs, Cimplicant_vardecl},
		                            {A1, Cimplicant_body},
		                            {Q, consumed_LA2}},
		                           ts_vardecl}};

	std::cout << "ts_result = " << oc_to_string(ts_result) << std::endl;
	std::cout << "ts_expected = " << oc_to_string(ts_expected) << std::endl;

	TS_ASSERT(tss_content_eq(ts_result, ts_expected));
}

void UnifyUTest::test_unify_complex_2()
{
	Handle lhs =
		_eval.eval_h("(ImplicationScopeLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (VariableNode \"$P-55ebe96e\")"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"compound-A\"))))");

	Handle rhs =
		_eval.eval_h("(ImplicationScopeLink"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$X\")"
		             "    (TypeNode \"ConceptNode\"))"
		             "  (AndLink"
		             "    (EvaluationLink"
		             "      (PredicateNode \"contain\")"
		             "      (ListLink"
		             "        (VariableNode \"$Y-6f50cc6a\")"
		             "        (ConceptNode \"compound-A\")))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (VariableNode \"$Y-6f50cc6a\"))))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (ConceptNode \"compound-A\"))))");

	Handle lhs_vardecl =
		_eval.eval_h("(VariableNode \"$P-55ebe96e\")");

	Handle rhs_vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$Y-6f50cc6a\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle P = _eval.eval_h("(VariableNode \"$P-55ebe96e\")");

	Handle conjunction =
		_eval.eval_h("(AndLink"
		             "  (EvaluationLink"
		             "    (PredicateNode \"contain\")"
		             "    (ListLink"
		             "      (VariableNode \"$Y-6f50cc6a\")"
		             "      (ConceptNode \"compound-A\")))"
		             "  (EvaluationLink"
		             "    (PredicateNode \"take\")"
		             "    (ListLink"
		             "      (VariableNode \"$X\")"
		             "      (VariableNode \"$Y-6f50cc6a\"))))");
	Unify::Context C(Quotation(), {X});
	Unify::CHandle CP(P, C);
	Unify::CHandle Cconjunction(conjunction, C);

	Unify::SolutionSet result = Unify()(lhs, rhs, lhs_vardecl, rhs_vardecl);
	Unify::Block pb_expected{CP, Cconjunction};
	Unify::Partition partition_expected{{pb_expected, conjunction}};
	Unify::SolutionSet expected = Unify::SolutionSet(true, {partition_expected});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);

	Handle ts_vardecl = _eval.eval_h("(VariableList"
	                                 "  (VariableNode \"$P-55ebe96e\")"
	                                 "  (TypedVariableLink"
	                                 "    (VariableNode \"$Y-6f50cc6a\")"
	                                 "    (TypeNode \"ConceptNode\")))");

	Unify::TypedSubstitutions tss_result =
		Unify().typed_substitutions(result, lhs, lhs, rhs,
		                            lhs_vardecl, rhs_vardecl);
	Unify::HandleCHandleMap hchm_expected =
		Unify::HandleCHandleMap{{P, Cconjunction}};
	Unify::TypedSubstitution ts_expected =
		Unify::TypedSubstitution{hchm_expected, ts_vardecl};
	Unify::TypedSubstitutions tss_expected =
		Unify::TypedSubstitutions{ts_expected};

	std::cout << "tss_result = " << oc_to_string(tss_result) << std::endl;
	std::cout << "tss_expected = " << oc_to_string(tss_expected) << std::endl;

	TS_ASSERT(tss_content_eq(tss_result, tss_expected));
}

void UnifyUTest::test_unify_complex_3()
{
	Handle lhs =
		_eval.eval_h("(ImplicationLink"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-3753c5dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$Q-79152fc8\"))))"
		             "  (LambdaLink"
		             "    (TypedVariableLink"
		             "      (VariableNode \"$X\")"
		             "      (TypeNode \"ConceptNode\"))"
		             "    (EvaluationLink"
		             "      (PredicateNode \"take\")"
		             "      (ListLink"
		             "        (VariableNode \"$X\")"
		             "        (ConceptNode \"compound-A\")))))");

	Handle rhs =
		_eval.eval_h("(ImplicationLink"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-7b18f3dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$P-60bdbde3\"))))"
		             "  (QuoteLink"
		             "    (LambdaLink"
		             "      (UnquoteLink"
		             "        (VariableNode \"$TyVs-7b18f3dc\"))"
		             "      (UnquoteLink"
		             "        (VariableNode \"$Q-344be2a0\")))))");

	Handle lhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs-3753c5dc\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (VariableNode \"$Q-79152fc8\"))");

	Handle rhs_vardecl =
		_eval.eval_h("(VariableList"
		             "  (TypedVariableLink"
		             "    (VariableNode \"$TyVs-7b18f3dc\")"
		             "    (TypeChoice"
		             "      (TypeNode \"TypedVariableLink\")"
		             "      (TypeNode \"VariableList\")))"
		             "  (VariableNode \"$P-60bdbde3\")"
		             "  (VariableNode \"$Q-344be2a0\"))");

	Handle TyVs1 = _eval.eval_h("(VariableNode \"$TyVs-3753c5dc\")");
	Handle TyVs2 = _eval.eval_h("(VariableNode \"$TyVs-7b18f3dc\")");
	Handle Q1 = _eval.eval_h("(VariableNode \"$Q-79152fc8\")");
	Handle Q2 = _eval.eval_h("(VariableNode \"$Q-344be2a0\")");
	Handle P =_eval.eval_h("(VariableNode \"$P-60bdbde3\")");

	Handle vardecl =
		_eval.eval_h("(TypedVariableLink"
		             "  (VariableNode \"$X\")"
		             "  (TypeNode \"ConceptNode\"))");

	Handle implicant_body =
		_eval.eval_h("(EvaluationLink"
		             "  (PredicateNode \"take\")"
		             "  (ListLink"
		             "    (VariableNode \"$X\")"
		             "    (ConceptNode \"compound-A\")))");

	Unify::Context C(Quotation(), {X});
	Unify::CHandle Cvardecl(vardecl, C), Cimplicant_body(implicant_body, C);

	Unify::SolutionSet result = Unify()(lhs, rhs, lhs_vardecl, rhs_vardecl),
		expected = Unify::SolutionSet(true,
		                              {{{{TyVs1, TyVs2, Cvardecl}, vardecl},
				                        {{Q1, P}, Q1},
				                        {{Q2, Cimplicant_body}, implicant_body}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}
